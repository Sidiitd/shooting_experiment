# HEADER
'''   
@file:          workspace.py
@brief:    	    This module provides a class containing all the information regarding the workspace of a manipulator.
@author:        Nima Ramezani Taghiabadi
                PhD Researcher
                Faculty of Engineering and Information Technology
                University of Technology Sydney
                Broadway, Ultimo, NSW 2007
                Room No.: CB10.03.512
                Phone:    02 9514 4621
                Mobile:   04 5027 4611
                Email(1): Nima.RamezaniTaghiabadi@student.uts.edu.au 
                Email(2): nima.ramezani@gmail.com
                Email(3): nima_ramezani@yahoo.com
                Email(4): ramezanitn@alum.sharif.edu
@version:	    1.5
Last Revision:  23 October 2012
'''
# BODY

import  numpy,copy, pickle

import  packages.nima.robotics.kinematics.kinematicpy.forward_kinematics as fklib

from    packages.nima.mathematics import rotation
from    packages.nima.artificial_intelligence.data_mining.kdtree import kdtree


def read_from_file(path_and_file_name):
    '''
    read and return the workspace from file specified by filename. The output is an instance of class "Workspace"
    '''
    FILE_DATA = open(path_and_file_name, "r")
    work_space = pickle.load(FILE_DATA)
    return work_space

class Workspace_Settings():
    '''
    '''
    all_creation_methods                = ['Joint Space Grid', 'Random', 'Constant Set']
    all_search_criteria                 = ['Nearest to Target Pose', 'Nearest to Current Configuration', 'Set Order']

    def __init__( self, creation_method = 'Joint Space Grid', grid_resolution = 2, representation_of_orientation = 'angular_spherical', number_of_search_items = 1, number_of_configs = 10, search_criteria = 'Nearest to Target Pose'):

        '''
        creation_method: Configuration Generation Method
        
        Possible methods are:
        
        'Joint Space Grid'      (key = 'JSG'):  Initial Configurations generated by FK computations of configs of a grid of jointspace
        'Random'                (key = 'RND'):  Initial Configurations generated randomly (Additional time required only for generating random configurations)
        'Constant Set'          (key = 'CST'):  Initial Configurations read from a list of Configurations corresponding to a "Constant Set of Poses" (No additional time required)
        '''
        self.creation_method                  = creation_method
        # "number_of_intervals": determines the number of intervals, each joint takes in the jointspace grid
        self.grid_resolution                  = grid_resolution
        # e.g. 'vectorial_identity'
        self.representation_of_orientation    = representation_of_orientation 
        self.number_of_search_items           = number_of_search_items
        self.number_of_configs                = number_of_configs
        self.search_criteria                  = search_criteria
        
        self.read_workspace                   = False
        self.write_workspace                  = False
        
    def represent_orient_key(self):
        if self.representation_of_orientation == 'angular_spherical':
            return 'AngSph'
        elif self.representation_of_orientation == 'vectorial_identity':
            return 'VecIty'
        elif self.representation_of_orientation == 'Rotation Matrix':
            return 'RotMtx'
        else:
            assert False    

    def search_criteria_key(self):
        if self.search_criteria == 'Nearest to Target Pose':
            return 'NTP' + str(self.number_of_search_items)
        elif self.search_criteria == 'Nearest to Current Configuration':
            return 'NCC' + str(self.number_of_search_items)
        elif self.search_criteria == 'Set Order':
            return 'SOR' + str(self.number_of_search_items)
        else:
            assert False    

    def gen_key(self):
        if self.creation_method == 'Joint Space Grid':
            return 'JSG' + str(self.grid_resolution)
        elif self.creation_method == 'Random':   
            return 'RND' + str(self.number_of_configs)
        elif self.creation_method == 'Constant Set':   
            return 'CST' + str(self.number_of_configs)
        else:
            assert False
            
    def gen_file_name(self, manip_name):
        return manip_name + '_' + self.gen_key() + '_' + self.represent_orient_key() + '.ws'
        
    def __str__(self):
        s  = "\n"
        s += "Workspace Settings: " + "\n" + "\n"
        s += "Creation Method:                " + self.creation_method + "\n"
        s += "Grid Resolution:                " + str(self.grid_resolution) + "\n"
        s += "Representation of Orientation:  " + self.representation_of_orientation  + "\n"
        s += "Number of Configurations:       " + str(self.number_of_configs)  + "\n"
        s += "Number of Search Items:         " + str(self.number_of_search_items)  + "\n"
        s += "Search Criteria:                " + self.search_criteria  + "\n"
        
        return s        
        
        
class Workspace():
    '''
    This class inherits DH parameters from class: "Manipulator_Geometry" 
    It contains pre-computed kinematic properties of a manipulator in a discretized grid of the jointspace.
    These properties are in two equivalent lists named "config_list" and "pose_list"
    '''
    
    def __init__( self, settings):
        '''
        '''
        self.settings = settings
        # "config_list": List of configurations of a discretized jointspace grid. (Number of values for each joint is identified by property: "number_of_intervals") 
        #  list length  = (number_of_intervals ** DOF)
        self.config_list         = []
        # "pose_list": A List of poses equivalent to "config_list". Each list element is a pose vector corresponding to its equivalent configuration in the "config_list"
        self.pose_list           = []
        # "lower_pose" and "upper_pose" contain the lower and upper bounds of each element in the pose list
        self.lower_pose          = ()
        self.upper_pose          = ()
        
        # kd trees : 
        self.pose_tree           = None
        
        # TODO (principally): distance function for rotational joints ?!
        # ... for second use case ... 
        self.config_tree         = None

    def create_random(self, geo, config, endeff):
        '''
        Generate a number of random configs in the feasible range of the jointspace and computes the forward kinematic of each configuration.
        The number of random points generated are determined by property: "self.settings.number_of_configs" 
        The configurations are stored in property "self.config_list" and the corresponding poses are stored in property "self.pose_list"
        A pose contains 3 elements for each position (reference_position) and 3 elements for each orientation (reference_orientation)
        
        A nun-redundant parametrization for orientation should be introduced by property "self.representation_of_orientation"
        '''

        p                      = self.settings.number_of_configs
        fwd_kin                = fklib.Forward_Kinematics(geo, config)

        # save current tasklist for endeffector       
        keep_endeff_task_list = copy.copy(endeff.tasklist)
        
        fwd_kin.tasklist       = ['update_transfer_matrices']
        endeff.tasklist        = ['update_taskspace_pose']
        
        for i in range(0, p):
            print 'Creating Workspace .... ' + str(i) + ' out of: ' + str (p)
            ef_pose = ()
            
            fwd_kin.take_to_random_configuration()
            endeff.update(fwd_kin)
            
            for tp in endeff.reference_positions:
                for j in range(0,3):
                    ef_pose += tp.ra[j],
            
            ef_pose = endeff.pose_to_tuple('actual', self.settings.representation_of_orientation)

            self.pose_list.append(ef_pose)
            self.config_list.append(numpy.copy(fwd_kin.configuration.q))

        pose_set   = set(self.pose_list)
        config_tuple_list = [ tuple(c) for c in self.config_list  ]
        config_set = set(config_tuple_list)
        
        self.pose_tree      = kdtree.KDTree.construct_from_data(list(pose_set))
        self.config_tree    = kdtree.KDTree.construct_from_data(list(config_set))



        # return back tasklist for endeffector       
        endeff.tasklist  = copy.copy(keep_endeff_task_list)

    def create_JSG(self, geo, config, endeff):
        '''
        Generate a lattice in the jointspace and computes the forward kinematic of each configuration.
        The feasible range of each jach joint is divided by "self.settings.grid_resolution" + 1 intervals. 
        The configurations are sstored in property "self.config_list" and the corresponding poses are stored in property "self.pose_list"
        A pose contains 3 elements for each position (reference_position) and 3 elements for each orientation (reference_orientation)
        
        A nun-redundant parametrization for orientation should be introduced by property "self.representation_of_orientation"
        
        '''

        p                      = self.settings.grid_resolution ** config.DOF
        fwd_kin                = fklib.Forward_Kinematics(geo, config)
        self.settings.number_of_configs = p

        # save current tasklist for endeffector       
        keep_endeff_task_list = copy.copy(endeff.tasklist)
        
        fwd_kin.tasklist       = ['update_transfer_matrices']
        endeff.tasklist        = ['update_taskspace_pose']
        
        fwd_kin.take_to_grid_configuration(0, self.settings.grid_resolution)
        endeff.update(fwd_kin)

        for tp in endeff.reference_positions:
            tp.ru = numpy.copy(tp.ra)
            tp.rl = numpy.copy(tp.ra)
            
        for i in range(0, p):
            print 'Creating Workspace .... ' + str(i) + ' out of: ' + str (p)
            ef_pose = ()
            fwd_kin.take_to_grid_configuration(i, self.settings.grid_resolution)
            endeff.update(fwd_kin)
            
            for tp in endeff.reference_positions:
                for j in range(0,3):
                    if (tp.ra[j] > tp.ru[j]):
                        tp.ru[j] = tp.ra[j]
                        
                    if (tp.ra[j] < tp.rl[j]):
                        tp.rl[j] = tp.ra[j]
            
            ef_pose = endeff.pose_to_tuple('actual', self.settings.representation_of_orientation)

            self.pose_list.append(ef_pose)
            q = numpy.copy(fwd_kin.configuration.q)
            fwd_kin.configuration.initialize()
            self.config_list.append(q)

        self.lower_pose          = ()
        self.upper_pose          = ()
        
        for tp in endeff.reference_positions:
            for j in range(0,3):
                self.lower_pose  += tp.rl[j],
                self.upper_pose  += tp.ru[j],
            
        pose_set   = set(self.pose_list)
        config_tuple_list = [ tuple(c) for c in self.config_list  ]
        config_set = set(config_tuple_list)
        
        self.pose_tree      = kdtree.KDTree.construct_from_data(list(pose_set))
        self.config_tree    = kdtree.KDTree.construct_from_data(list(config_set))

        # return back tasklist for endeffector       
        endeff.tasklist  = copy.copy(keep_endeff_task_list)
        self.file_name   = self.settings.gen_file_name(geo.name)

    def create(self, geo, config, endeff):
        
        if self.settings.creation_method == 'Joint Space Grid':
            self.create_JSG(geo, config, endeff)
        elif self.settings.creation_method == 'Random':
            self.create_random(geo, config, endeff)
        elif self.settings.creation_method == 'Constant Set':
            
            assert len(self.pose_list) == len(self.config_list)
            self.settings.number_of_configs = len(self.config_list)
            pose_set   = set(self.pose_list)
            config_tuple_list = [ tuple(c) for c in self.config_list  ]
            config_set = set(config_tuple_list)
            
            self.pose_tree      = kdtree.KDTree.construct_from_data(list(pose_set))
            self.config_tree    = kdtree.KDTree.construct_from_data(list(config_set))
            
        else:
            assert False    
            

    def configs_nearest_to_target(self, endeff):
        '''
        endeff contains the target pose         
        
        Return a list of configurations which:
            Their corresponding poses are closest to the target pose 
    
        QUESTION : configs_nearest_to_target( EE, distance ? ) ?? 
        '''
        #first find the 10 closest poses to target
        target_pose = endeff.pose_to_tuple('desired', self.settings.representation_of_orientation)
        nearest_pose = self.pose_tree.query(query_point = target_pose, t = self.settings.number_of_search_items)
        nearest_config_list = []
        
        for pose in nearest_pose:
            nearest_config_list.append(numpy.copy(self.config_list[self.pose_list.index(pose)]))

        return nearest_config_list

    def configs_nearest_to_current_configuration(self, current_q):

        '''
        Return a list of configurations which:
            Are closest to the starting configuration
        
        (second  / online usecase : time coherence ... ) 
        '''
        if self.settings.number_of_search_items == 0:
            return []
        
        #first find the closest configurations to the current configuration
        nearest_config_list   = self.config_tree.query(query_point = current_q, t = self.settings.number_of_search_items)
        
        return nearest_config_list

    def nearest_configs(self, ik):
        if self.settings.search_criteria   == 'Nearest to Target Pose': # (key: NTP) Initial Configuration: Nearest to Target Pose
            nearest_config_list = self.configs_nearest_to_target(ik.endeffector)
        elif self.settings.search_criteria == 'Nearest to Current Configuration': # (key: NCC) Initial Configuration: Nearest to Current Configuration
            nearest_config_list = self.configs_nearest_to_current_configuration(ik.configuration.q)
        elif self.settings.search_criteria == 'Set Order': 
            nearest_config_list = []
            for i in range(self.settings.number_of_search_items):
                nearest_config_list.append(self.config_list[i])
        
        else :
            assert False    
           
        return nearest_config_list
        
    def write_to_file(self, path_and_file_name):
        '''
        Save the class in file specified by "self.file_name"
        '''
        FILE_DATA = open(path_and_file_name, "w")
        pickle.dump(self, FILE_DATA)
        
        

