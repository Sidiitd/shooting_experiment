# HEADER

## @file        	trajectory.py
#  @brief           This module provides a class containing a trajectory in the multi-dimensional space.
#                   The path is generated by a number of key points containing poses, twists 
#                   with their corresponding phase values ($f \phi $f)
#  @author      	Nima Ramezani Taghiabadi 
#
#               	PhD Researcher 
#               	Faculty of Engineering and Information Technology 
#               	University of Technology Sydney (UTS) 
#               	Broadway, Ultimo, NSW 2007, Australia 
#               	Phone No. :   04 5027 4611 
#               	Email(1)  : nima.ramezani@gmail.com 
#               	Email(2)  : Nima.RamezaniTaghiabadi@uts.edu.au 
#  @version     	6.0
#
#  Last Revision:  	03 January 2015

# BODY

import copy, math, sys, numpy as np

import matplotlib as mpl
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

import general_python as genpy
from math_tools import general_math as genmath
from math_tools.algebra import polynomials as pl
from math_tools.geometry import geometry as geo

## This class, introduces a structure for a key point in the multi-dimensional space. 
#  Key points are used to generate a trajectory. 
#  A key point contains a phase value specifying the point phase (time), 
#  and three numpy vectors specifying the desired position, velocity and acceleration at that point.
#  The values of some or all elements of velocity, acceleration and position can be None 
#  but for each key point, at least one position, velocity or acceleration value must be specified per each element.
class Key_Point(object):
    
   ## Class Constructor
   #  @param phi The phase value (\f$ \phi \f$) of the key point
   #  @param pos The desired position vector at the key point
   #  @param vel The desired velocity vector at the key point
   #  @param acc The desired acceleration vector at the key point   
   def __init__(self, phi, pos, vel = None, acc = None):
       
       ## An integer indicating the dimension of space in which the kepy point is defined.
       #  This number specifies the number of elements of position, velocity and acceleration vectors  
       self.dim     = len(pos) 
       
       # A real float indicating the phase value of the key point
       self.phi     = phi
       
       # A numpy vector indicating the position of the key point
       self.pos     = pos
       
       # A numpy vector indicating the velocity of the key point
       self.vel     = vel
       
       # A numpy vector indicating the acceleration of the key point
       self.acc     = acc  

   ## This function is the string representation of the key point
   #  @param None
   #  @return A string representing all the information about the key point  
   def __str__( self ):
       s  = "Point Dimension: " + str(self.dim) + '\n' 
       s += "Phase       : " + str(self.phi) + '\n'
       s += "Position    : " + str(self.pos) + '\n'
       s += "Velocity    : " + str(self.vel) + '\n'
       s += "Acceleration: " + str(self.acc) + '\n'
       return s

   ## Use this function to get the current value of position, velocity or acceleration in a desired dimension 
   #  @param field_name A string, must be selected from 
   #                    set: ['position', 'velocity', 'acceleration'  
   #                    specifying which vector is desired.  
   #  @param axis A non-negative integer specifying which element of the vector should be returned. 
   #             (Must not be greater than the space dimension) 
   #  @return A float containing the value of the element specified by argument \b axis from the vector specified by argument \b field_name   
   def value(self, field_name = 'position', axis = 0):
       assert (axis <= self.dim), "Error from " + __name__ + func_name + ": Argument axis must not esxeed the space dimension"
       assert (axis >= 0), "Error from " + __name__ + func_name + ": Argument axis can not have a negative value"  
       
       if field_name == 'position':
           return self.pos[axis]
       elif field_name == 'velocity':
           return self.vel[axis]
       elif field_name == 'acceleration':
           return self.acc[axis]
       else:
           print "Error from " + __name__ + func_name + ": " + field_name + " is not not a valid value for argument field_name"

## This class contains properties and methods for a <em> Trajectory Segment </em>
#  A trajectory is established of one segment or a number of segments connected together creating a path in the space. 
#  Each segment, contains a number of instances of class Key_Point().
class Path(object):
    
    ## Class Constructor
    #  @param dimension A positive integer specifying the dimension of the space in which the trajectory segment is defined
    def __init__(self, dimension = 3, capacity = 3):
        # By default, initially the trajectory is a constant position at [0,0,0] (not changing)
        # You should add points to it to make your trajectory

        self.current_phi            = 0.0
        self.phi_end                = 0.0
        self.capacity               = capacity # determines how many key points it can hold

        self.dim                    = dimension
        self.current_position       = np.zeros(self.dim)
        self.current_velocity       = np.zeros(self.dim)
        self.current_acceleration   = np.zeros(self.dim)

        self.point = []

    ## String representation of the instance (trajectory segment)
    #  @param  None
    #  @return A string containing the main information about the trajectory segment
    def __str__( self ):
        s  = "Phase Length     : " + str(self.phi_end) + '\n' 
        s += "Number of Points : " + str(len(self.point)) + '\n'
        s += "Segment Starting Point: " + '\n'
        s += str(self.point[0]) + '\n'
        s += "Segment End Point: " + '\n'
        s += str(self.point[len(self.point) - 1]) + '\n'
        return s

    ## Use this function to append a key point to the end of the trajectory segment
    #  @param phi The phase value (\f$ \phi \f$) of the key point to be added
    #  @param pos The desired position vector at the key point to be added
    #  @param vel The desired velocity vector at the key point to be added
    #  @param acc The desired acceleration vector at the key point to be added
    #  @return None   
    def add_point(self, phi, pos, vel = None, acc = None):
        n = len(self.point)
        assert n < self.capacity, genpy.err_str(__name__, self.__class__.__name__, sys._getframe().f_code.co_name, "The path capacity is full! Can not take more points than its capacity")

        if n > 0:
            assert phi >= self.point[n-1].phi, genpy.err_str(__name__, self.__class__.__name__, sys._getframe().f_code.co_name, "Given phi is less than the last point's phase")

        nn  = np.array([None for j in range(self.dim)])
        pos = genpy.check_type(pos, [np.ndarray], __name__, self.__class__.__name__, sys._getframe().f_code.co_name, 'pos', array_length = self.dim, default = np.copy(nn))
        vel = genpy.check_type(vel, [np.ndarray], __name__, self.__class__.__name__, sys._getframe().f_code.co_name, 'vel', array_length = self.dim, default = np.copy(nn))
        acc = genpy.check_type(acc, [np.ndarray], __name__, self.__class__.__name__, sys._getframe().f_code.co_name, 'acc', array_length = self.dim, default = np.copy(nn))

        self.point.append(Key_Point(phi, pos, vel, acc))
        self.phi_end     = phi

    ## Computes the euclidean distances of each key point from the next and return the result in a vector.
    #  The segment must have at least two key points, otherwise an error is printed and None is returned. 
    #  @param None
    #  @return A numpy vector containing the distance between the points  
    def points_dist(self):
        n_pnt = len(self.point)
        if n_pnt > 1:  
            dist  = np.zeros(n_pnt - 1)
            for i in range(n_pnt - 1):
                dist[i] = np.linalg.norm(self.point[i+1].pos - self.point[i].pos)
            return dist
        else:
             assert False,  genpy.err_str(__name__, self.__class__.__name__, 'points_dist', 'The segment must have at least two key points')

    def closest_keypoint_number(self, phi = None):
        if phi == None:
            phi = self.current_phi
        npnt = len(self.point) # Number of key points
        i    = 0
        while (self.point[i].phi < self.current_phi) and (i < npnt - 1):
            i  += 1
        return i

    ## Sets the current phase value
    #  @param phi A float specifying the desired phase value. The given value must not exceed the phase of the last key point.
    #  @return None
    def set_phi(self, phi):
        '''
        check phi to be valid. Many changes must be delivered. 
            1- current_position must be a function returning property pos
        '''
        if not genmath.equal(phi, self.current_phi):
            assert phi <= self.phi_end, genpy.err_str(__name__, __class__.__name__, 'set_phi', 'Given phi (' + str(phi) + ') is greater than the phase of the last key point (' + str(self.phi_end) + ')')
            assert len(self.point) > 1, genpy.err_str(__name__, __class__.__name__, 'value', 'Can not change the phase when there are less than two key points!')        
            self.current_phi      = phi
            i                     = self.closest_keypoint_number()
            k                     = (self.current_phi - self.point[i-1].phi)/(self.point[i].phi - self.point[i-1].phi)
            for j in range(self.dim):
                if (self.point[i].pos[j] != None) and (self.point[i-1].pos[j] != None):
                    self.current_position[j] = self.point[i-1].pos[j] + k*(self.point[i].pos[j] - self.point[i-1].pos[j])
                else:
                    self.current_position[j] = None

                if (self.point[i].vel[j] != None) and (self.point[i-1].vel[j] != None):
                    self.current_velocity[j] = self.point[i-1].vel[j] + k*(self.point[i].vel[j] - self.point[i-1].vel[j])
                else:
                    if (self.point[i].pos[j] != None) and (self.point[i-1].pos[j] != None):
                        self.current_velocity[j] = (self.point[i].pos[j] - self.point[i-1].pos[j])/(self.point[i].phi - self.point[i-1].phi)
                    else:
                        self.current_velocity[j] = None
        
                if (self.point[i].acc[j] != None) and (self.point[i-1].acc[j] != None):
                    self.current_acceleration[j] = self.point[i-1].acc[j] + k*(self.point[i].acc[j] - self.point[i-1].acc[j])
                else:
                    if (self.point[i].vel[j] != None) and (self.point[i-1].vel[j] != None):
                        self.current_acceleration[j] = (self.point[i].vel[j] - self.point[i-1].vel[j])/(self.point[i].vel[j] - self.point[i-1].vel[j])
                    else:
                        self.current_acceleration[j] = None

    def map_phi(self, phi_start = 0, phi_end = 1.0):
        '''
        Maps the current trajectory phase interval to the given interval (phi_start, phi_end)
        and adjusts all keypoint phases, velocities and accelerations accordingly
        The segment will be interpolated after that
        Also the current_phi will be changed to the mapped value
        '''
        self.phi_start = self.point[0].phi
        delta_phi = self.phi_end - self.phi_start
        delta_the = phi_end - phi_start
        r         = delta_the/delta_phi
        for pnt in self.point:
            x       = (pnt.phi - self.phi_start)/delta_phi # x must be between 0 and 1
            the     = phi_start + x*delta_the
            pnt.phi = the
            for j in range(self.dim):
                if pnt.vel[j] != None:
                    pnt.vel[j] = pnt.vel[j]/r
                if pnt.acc[j] != None:
                    pnt.acc[j] = pnt.acc[j]/(r*r)

        x       = (self.current_phi - self.phi_start)/delta_phi # x must be between 0 and 1
        self.current_phi = phi_start + x*delta_the
        
        self.phi_start = phi_start    
        self.phi_end   = phi_end
        self.interpolate()

    def current_value(self, field_name= 'position', axis = 0):

        if field_name == 'position':
            return self.current_position[axis]
        elif field_name == 'velocity':
            return self.current_velocity[axis]
        elif field_name == 'acceleration':
            return self.current_acceleration[axis]
        else:
            print "Error from Path.current_value(): Given field_name is not valid"
    
    def plot(self, axis = 0, n = 100, y_text = "", wtp = 'position', show_points = False):
        if y_text == "":
            s = wtp + " of Axis " + str(axis)
        else:
            s = wtp + " of " + y_text

        x = np.append(np.arange(0.0, self.phi_end, self.phi_end/n), self.phi_end)
        y = []
        for t in x:
            self.set_phi(t)
            y.append(self.current_value(field_name = wtp, axis = axis))
        if show_points:
            px = []
            py = []
            for pnt in self.point:
                px.append(pnt.phi)
                py.append(pnt.value(field_name = wtp, axis = axis))

            plt.plot(x, y, px, py, 'o') 
        else:
            plt.plot(x, y) 

        plt.ylabel(s)
        plt.xlabel('phi')
        plt.show()

    def scatter_plot(self, wtp = 'position', axis_x = 0, axis_y = 1, n = 100, y_text = "", show_points = False):

        t = np.append(np.arange(0.0, self.phi_end, self.phi_end/n), self.phi_end)
        x = []
        y = []
        for ph in t:
            self.set_phi(ph)
            x.append(self.current_value(field_name = wtp, axis = axis_x))
            y.append(self.current_value(field_name = wtp, axis = axis_y))

        if show_points:
            px = []
            py = []
            for pnt in self.point:
                px.append(pnt.value(field_name = wtp, axis = axis_x))
                py.append(pnt.value(field_name = wtp, axis = axis_y))

            plt.plot(x, y, px, py, 'o') 
        else:
            plt.plot(x, y) 

        plt.ylabel('Y')
        plt.xlabel('X')
        plt.show()

class Path_Polynomial(Path):
    ## Class Constrauctor
    def __init__(self, dimension = 3, capacity = 3):
        super(Path_Polynomial, self).__init__(dimension = dimension, capacity = capacity)            
        self.traj = [pl.Polynomial() for j in range(self.dim)] 

    def interpolate(self):
        '''
        specifies the coefficients of the trajectory_tbc_path which passes through a number of poses
        At least one position and one phi is required.
        phi[0] must be zero.
        '''
        n = len(self.point)
        if n > 1:
            pnt = [[] for j in range(self.dim)]

            for i in range(n):
                for j in range(self.dim):
                    pnt[j].append(pl.Point(t = self.point[i].phi, x = self.point[i].pos[j], v = self.point[i].vel[j], a = self.point[i].acc[j]))

            for j in range(self.dim):
                self.traj[j].interpolate_smart(pnt[j])

            self.phi_end = self.point[n-1].phi
            return True
        else:
            print "Error from Path_Polynomial.interpolate(): No key points defined !"
            return False 

    ## Sets the current phase value
    #  @param phi A float specifying the desired phase value. The given value must not exceed the phase of the last key point.
    #  @return None
    def set_phi(self, phi):
        '''
        check phi to be valid. Many changes must be delivered. 
            1- current_position must be a function returning property pos
        '''
        # if not genmath.equal(phi, self.current_phi):
        assert phi <= self.phi_end, genpy.err_str(__name__, self.__class__.__name__, 'set_phi', 'Given phi (' + str(phi) + ') is greater than the phase of the last key point (' + str(self.phi_end) + ')')
        assert len(self.point) > 1, genpy.err_str(__name__, self.__class__.__name__, 'value', 'Can not change the phase when there are less than two key points!')        
        self.current_phi      = phi

        self.current_position = np.zeros(self.dim)
        self.current_velocity = np.zeros(self.dim)
        self.current_acceleration = np.zeros(self.dim)
        for j in range(self.dim):
            self.current_position[j]     = self.traj[j].position( t = phi )
            self.current_velocity[j]     = self.traj[j].velocity( t = phi )
            self.current_acceleration[j] = self.traj[j].acceleration( t = phi )

class Orientation_Path(Path):
    def __init__(self, representation = 'vector', parametrization = 'identity', capacity = 2):
        super(Orientation_Path, self).__init__(dimension = 3, capacity = capacity)    
        self.current_orientation  = geo.Orientation_3D(ori = self.current_position, ori_velocity = self.current_velocity, ori_acceleration = self.current_acceleration, representation = representation, parametrization = parametrization)

    def set_phi(self, phi):
        super(Orientation_Path, self).set_phi(phi = phi)
        self.current_orientation[self.current_orientation.representation] = self.current_position
        self.current_orientation.set_velocity(value = self.current_velocity)
        self.current_orientation.set_acceleration(value = self.current_acceleration)

    def add_point(self, phi, ori):
        rpn                     = self.current_orientation.representation
        ori.parametrization = self.current_orientation.parametrization
        pos = ori[rpn]
        vel = ori[rpn + '_velocity']
        acc = ori[rpn + '_acceleration']
        super(Orientation_Path, self).add_point(phi, pos, vel, acc)

class Orientation_Path_Polynomial(Orientation_Path, Path_Polynomial):
    def __init__(self, representation = 'vector', parametrization = 'identity'):
        super(Orientation_Path_Polynomial, self).__init__(representation = representation, parametrization = parametrization)    

class Trajectory(object):

    def __init__(self, dimension = 3, capacity = 3):
        self.dim            = dimension

        ## Specifies the default segment capacity. 
        #  When a new segment is added, it will have the default capacity unless specified differently.
        self.capacity       =  capacity

        self.current_position       = np.zeros(self.dim)
        self.current_velocity       = np.zeros(self.dim)
        self.current_acceleration   = np.zeros(self.dim)

        self.segment        = []
        self.segment_start  = []
        self.phi_end        = 0.0
        self.current_phi    = 0.0

    def __str__( self ):
        s  = "Trajectory Phase Length : " + str(self.phi_end) + '\n' 
        s += "Number of Segments      : " + str(len(self.segment)) + '\n'
        for i in range(len(self.segment)):
            s += "Segment Number " + str(i) + " starting at phi = " + str(self.segment_start[i]) + ': \n'
            s += str(self.segment[i])
            s += "****************************************** \n" 
        return s

    def current_value(self, field_name= 'position', axis = 0):

        if field_name == 'position':
            return self.current_position[axis]
        elif field_name == 'velocity':
            return self.current_velocity[axis]
        elif field_name == 'acceleration':
            return self.current_acceleration[axis]
        else:
            print "Error from Path.current_value(): Given field_name is not valid"

    def add_segment(self, new_seg):

        self.segment.append(new_seg)
        self.segment_start.append(self.phi_end)
        self.phi_end = self.phi_end + new_seg.phi_end

    def new_segment(self, capacity = None):
        capacity = genpy.check_type(capacity, self.capacity, [int], __name__, self.__class__.__name__, sys._getframe().f_code.co_name, 'capacity')
        nn   = np.array([None for j in range(self.dim)])
        lsi  = len(self.segment) - 1
        seg  = Path(dimension = self.dim, capacity = capacity) 
        assert len(self.segment[lsi].point) > 1, genpy.err_str(__name__, self.__class__.__name__, sys._getframe().f_code.co_name, 'Can not create a new segment. The last segment needs at least two points.')
        lslp = self.segment[lsi].point[len(self.segment[lsi].point) - 1] # last_seg_last_point
        seg.add_point(0.0, lslp.pos, nn, np.copy(nn))
        self.add_segment(seg)

    def points_dist(self):
        dist = np.array([])
        for seg in self.segment:
            dist = np.append(dist, seg.points_dist())
        return dist

    def adjust_phase_by_distance(self, gain = 1.0):
        n_seg = len(self.segment)
        self.segment_start[0] = 0.0
        self.phi_start        = 0.0
        for i in range(n_seg - 1):
            d = gain*sum(self.segment[i].points_dist())
            self.segment[i].map_phi(phi_end = d)
            self.segment_start[i + 1] = self.segment_start[i] + self.segment[i].phi_end

        d = gain*sum(self.segment[n_seg - 1].points_dist())        
        self.segment[n_seg - 1].map_phi(phi_end = d)                
        self.phi_end   = self.segment_start[n_seg - 1] + self.segment[n_seg - 1].phi_end
        self.interpolate()

    def set_phi(self, phi):

        if phi > self.phi_end:
            phi = self.phi_end

        self.current_phi = phi

        lsi     = len(self.segment)  - 1 # last segment index

        i = 0
        while (phi > self.segment_start[i] + self.segment[i].phi_end) and (i <= lsi):
            i += 1
        
        self.segment[i].set_phi(phi - self.segment_start[i])
        self.current_position = self.segment[i].current_position
        self.current_velocity = self.segment[i].current_velocity
        self.current_acceleration = self.segment[i].current_acceleration
 
    ## Use this function to append a key point to the end of the trajectory with desired position, velocity and acceleration
    #  The given point will be added to the end of the last segment of the trajectory, unless the segment capacity if full
    #  (number of segment points equals the capacity of that segment). 
    #  In this case, a new segment will be added and the given point is added to the new segment.
    #  The capacity of the added segment is specified by property self.capacity
    #  @param phi The phase value (\f$ \phi \f$) of the key point to be added. 
    #             This argument should be greater than the phase of the last added point specified by the property self.phi_end
    #  @param pos The desired position vector at the key point to be added
    #  @param vel The desired velocity vector at the key point to be added
    #  @param acc The desired acceleration vector at the key point to be added
    #  @return None   
    def add_point(self, phi, pos, vel = None, acc = None):
        genpy.check_type(phi, [float, np.float64], __name__, self.__class__.__name__,sys._getframe().f_code.co_name, 'phi', default = None)
        
        lsi = len(self.segment) - 1

        if lsi < 0:
            assert genmath.equal(phi, 0.0), genpy.err_str(__name__, self.__class__.__name__,sys._getframe().f_code.co_name, "Given phi is " + str(phi) + " which should be zero for the first point")
            seg = Path_Polynomial(dimension = self.dim) 
            seg.add_point(0.0, pos, vel, acc)
            self.add_segment(seg)
        else:
            assert (phi > self.phi_end) and (not genmath.equal(phi, self.phi_end)), genpy.err_str(__name__, self.__class__.__name__,sys._getframe().f_code.co_name, "Given phi is " + str(phi) + " which should be greater than the last point's phase " + str(self.phi_end))
            if len(self.segment[lsi].point) < self.segment[lsi].capacity:
                phi0 = self.segment_start[lsi]
                self.segment[lsi].add_point(phi - phi0, pos, vel, acc)
            else:
                self.new_segment()
                self.segment[lsi+1].add_point(phi-self.phi_end, pos, vel, acc)

        lsi = len(self.segment) - 1
        self.phi_end = self.segment_start[lsi] + self.segment[lsi].phi_end

    ## private
    def add_vector(self, delta_phi, delta_pos, vel = None, acc = None):
        assert delta_phi > 0
        phi  = self.phi_end + delta_phi
        lsi  = len(self.segment) - 1
        lslp = self.segment[lsi].point[len(self.segment[lsi].point) - 1] # last_seg_last_point

        pos = lslp.pos + delta_pos
        self.add_point(phi, pos, vel, acc)

    def map_phi(self, phi_start = 0, phi_end = 1.0):
        '''
        Maps the current trajectory phase interval to the given interval (phi_start, phi_end)
        and adjusts all keypoint phases, velocities and accelerations accordingly
        All the segments will be interpolated after that
        Also the current_phi will be changed to the mapped value
        '''
        self.phi_start = self.segment_start[0]
        n_seg     = len(self.segment)
        delta_phi = self.phi_end - self.phi_start
        delta_the = phi_end - phi_start
        r         = delta_the/delta_phi
        for i in range(n_seg):
            x       = (self.segment_start[i] - self.phi_start)/delta_phi # x must be between 0 and 1
            the     = phi_start + x*delta_the
            self.segment[i].map_phi(0.0, self.segment[i].phi_end*r)
            self.segment_start[i] = the

        x       = (self.current_phi - self.phi_start)/delta_phi # x must be between 0 and 1
        self.current_phi = phi_start + x*delta_the
        
        self.phi_start = phi_start    
        self.phi_end   = phi_end
      
    def plot(self, axis = 0, n = 100, y_text = "", wtp = 'position', show_points = False):
        if y_text == "":
            s = wtp + " of Axis " + str(axis)
        else:
            s = wtp + " of: " + y_text

        x = np.append(np.arange(0.0, self.phi_end, self.phi_end/n), self.phi_end)
        y = []
        for t in x:
            self.set_phi(t)
            y.append(self.current_value(field_name = wtp, axis = axis))
            

        if show_points:
            px = []
            py = []
            for i in range(len(self.segment)):
                for pnt in self.segment[i].point:
                    px.append(self.segment_start[i] + pnt.phi)
                    py.append(pnt.value(field_name = wtp, axis = axis))
                    

            plt.plot(x, y, px, py, 'o') 
        else:
            plt.plot(x, y) 

        plt.ylabel(s)
        plt.xlabel('phi')
        plt.show()

    def plot2d(self, wtp = 'position', axis_x = 0, axis_y = 1, n = 100, y_text = "", show_points = False):

        t = np.append(np.arange(0.0, self.phi_end, self.phi_end/n), self.phi_end)
        x = []
        y = []
        for ph in t:
            self.set_phi(ph)
            x.append(self.current_value(field_name = wtp, axis = axis_x))
            y.append(self.current_value(field_name = wtp, axis = axis_y))

        if show_points:
            px = []
            py = []
            for i in range(len(self.segment)):
                for pnt in self.segment[i].point:
                    px.append(pnt.value(field_name = wtp, axis = axis_x))
                    py.append(pnt.value(field_name = wtp, axis = axis_y))

            plt.plot(x, y, px, py, 'o') 
        else:
            plt.plot(x, y) 

        plt.ylabel('Y')
        plt.xlabel('X')
        plt.show()

    def plot3d(self, wtp = 'position', axis_x = 0, axis_y = 1, axis_z = 2, n = 100, label = "", show_points = False):

        t = np.append(np.arange(0.0, self.phi_end, self.phi_end/n), self.phi_end)
        mpl.rcParams['legend.fontsize'] = 10
        fig = plt.figure()
        ax = fig.gca(projection='3d')

        x = []
        y = []
        z = []
        for ph in t:
            self.set_phi(ph)
            x.append(self.current_value(field_name = wtp, axis = axis_x))
            y.append(self.current_value(field_name = wtp, axis = axis_y))
            z.append(self.current_value(field_name = wtp, axis = axis_z))

        ax.plot(x, y, z, label = label)
        ax.legend()
        plt.show()

class Orientation_Trajectory(Trajectory):
    def __init__(self, representation = 'vector', parametrization = 'identity'):
        super(Orientation_Trajectory, self).__init__()
        self.current_orientation    = geo.Orientation_3D(self.current_position, ori_velocity = self.current_velocity, ori_acceleration = self.current_acceleration, representation = representation, parametrization = parametrization)
    
    def set_phi(self, phi):
        super(Orientation_Trajectory, self).set_phi(phi = phi)
        self.current_orientation[self.current_orientation.representation] = self.current_position
        self.current_orientation.set_velocity(value = self.current_velocity)
        self.current_orientation.set_acceleration(value = self.current_acceleration)

    def add_point(self, phi, ori):
        rpn                     = self.current_orientation.representation
        ori.parametrization     = self.current_orientation.parametrization
        pos = ori[rpn]
        vel = ori[rpn + '_velocity']
        acc = ori[rpn + '_acceleration']
        super(Orientation_Trajectory, self).add_point(phi, pos, vel, acc)

class Trajectory_Polynomial(Trajectory):
    def __init__(self, dimension = 3, capacity = 3):
        super(Trajectory_Polynomial, self).__init__(dimension = dimension, capacity = capacity)

    def new_segment(self, capacity = None):
        capacity = genpy.check_type(capacity, [int], __name__, self.__class__.__name__, sys._getframe().f_code.co_name, 'capacity', default = self.capacity)
        nn   = np.array([None for j in range(self.dim)])
        lsi  = len(self.segment) - 1
        assert len(self.segment[lsi].point) > 1, genpy.err_str(__name__, self.__class__.__name__, 'new_segment', 'Can not create a new segment. The last segment needs at least two points.')
        seg  = Path_Polynomial(dimension = self.dim, capacity = capacity) 
        lslp = self.segment[lsi].point[len(self.segment[lsi].point) - 1] # last_seg_last_point
        seg.add_point(0.0, lslp.pos, nn, np.copy(nn))
        self.add_segment(seg)

    def interpolate(self):
        for seg in self.segment:
            seg.interpolate()

    def consistent_velocities(self):
        self.interpolate()
        lsi = len(self.segment) - 1

        for i in range(lsi + 1):
            lp  = self.segment[i].point[len(self.segment[i].point) - 1]  # last point
            ip1 = i + 1
            if ip1 > lsi:
                ip1 = 0 
            for j in range(self.dim):
                self.segment[i].set_phi(lp.phi)
                self.segment[ip1].set_phi(0.0)
                if lp.vel[j] == None:
                    if self.segment[ip1].point[0].vel[j] == None:
                        v = 0.5*(self.segment[i].current_velocity[j] + self.segment[ip1].current_velocity[j])
                        lp.vel[j] = v
                        self.segment[ip1].point[0].vel[j] = v
                    else:
                        lp.vel[j] = self.segment[ip1].point[0].vel[j]
                elif self.segment[ip1].point[0].vel[j] == None:
                    self.segment[ip1].point[0].vel[j] = lp.vel[j]
                elif not genmath.equal(lp.vel[j], self.segment[ip1].point[0].vel[j]):
                    v = 0.5*(lp.vel[j] + self.segment[ip1].point[0].vel[j])
                    lp.vel[j] = v
                    self.segment[ip1].point[0].vel[j] = v
                else:
                    # Already Consistent! Do nothing
                    assert True
    
        self.interpolate()         

    def consistent_accelerations(self):
        self.interpolate()
        lsi = len(self.segment) - 1
        self.segment[0].point[0].acc = np.zeros(self.dim)
        for i in range(lsi + 1):
            lp  = self.segment[i].point[len(self.segment[i].point) - 1]  # last point of segment i
            ip1 = i + 1
            if ip1 > lsi:
                ip1 = 0 
            for j in range(self.dim):
                self.segment[i].set_phi(lp.phi)
                self.segment[ip1].set_phi(0.0)
                if lp.acc[j] == None:
                    if self.segment[ip1].point[0].acc[j] == None:
                        a = 0.5*(self.segment[i].current_acceleration[j] + self.segment[ip1].current_acceleration[j])
                        lp.acc[j] = a
                        self.segment[ip1].point[0].acc[j] = a
                    else:
                        lp.acc[j] = self.segment[ip1].point[0].acc[j]
                elif self.segment[ip1].point[0].acc[j] == None:
                    self.segment[ip1].point[0].acc[j] = lp.acc[j]
                elif not genmath.equal(lp.acc[j], self.segment[ip1].point[0].acc[j]):
                    a = 0.5*(lp.acc[j] + self.segment[ip1].point[0].acc[j])
                    lp.acc[j] = a
                    self.segment[ip1].point[0].acc[j] = a
                else:
                    # Already Consistent! Do nothing
                    assert True
    
        self.interpolate()         

class Orientation_Trajectory_Polynomial(Orientation_Trajectory, Trajectory_Polynomial):
    def __init__(self, representation = 'vector', parametrization = 'identity'):
        super(Orientation_Trajectory_Polynomial, self).__init__(representation = representation, parametrization = parametrization)    
