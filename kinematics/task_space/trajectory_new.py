'''   Header
@file:          trajectory.py
@brief:    	    This module provides a class containing a trajectory in the taskspace.
                The path is generated by a number of key points containing poses, twists and corresponding phase phi
                
@author:        Nima Ramezani Taghiabadi
                PhD Researcher
                Faculty of Engineering and Information Technology
                University of Technology Sydney (UTS)
                Broadway, Ultimo, NSW 2007, Australia
                Room No.: CB10.03.512
                Phone:    02 9514 4621
                Mobile:   04 5027 4611
                Email(1): Nima.RamezaniTaghiabadi@student.uts.edu.au 
                Email(2): nima.ramezani@gmail.com
                Email(3): nima_ramezani@yahoo.com
                Email(4): ramezanitn@alum.sharif.edu
@version:	    4

Last Revision:  22 August 2014

Major changes from version 3:
    1- Trajectories now comprise of "segments" and "key_points". each segment, contains a number of key points.
       if the interpolation is "velocity_consistent" then the velocity in the sharing key_points must be eual
    2- In this stage, two segments can and must only have one keypoint in commomn.  

'''

import matplotlib.pyplot as plt
import numpy as np
import copy, math

from packages.nima.mathematics import polynomials as pl
from packages.nima.mathematics import general as gen


class Key_Point(object):
   def __init__(self, phi,pos,vel=None,acc=None):
       self.phi     = phi
       self.pos     = pos
       self.vel     = None   
       self.acc     = None   

class Trajectory(object):
    
    def __init__(self, dimension = 3):
        self.n = 1  # Number of keypoints. By default the trajectory is a constant pose (not changing)
        self.current_phi = 0.0
        self.phi_end = 1.0

        self.dim = dimension
        self.current_position = np.zeros(self.dim)
        self.current_velocity = np.zeros(self.dim)
        self.current_acceleration = np.zeros(self.dim)
        self.point = [Key_Point(phi = 0.0, pos = self.current_position, vel = self.current_velocity, acc = None)]
        self.segment = [[0]]
        self.interpolated = [False]
        self.max_num_key_points_in_a_seg = 3

    def add_point(self, phi, pos, vel = None, acc = None):
        n_seg = len(self.segment)
        self.point.append(Key_point(phi, pos, vel, acc))
        n_point = len(self.point)
        if len(self.segment[n_seg - 1]) < self.max_num_key_points_in_a_seg:
            self.segment[n_seg - 1].append(n_point - 1)
            self.interpolated[n_seg - 1] = False
        else:   
            self.segment.append([n_point - 1])
            self.interpolated.append[False]

    def all_segments_interpolated(self):
        asi = True
        for i in range(len(self.segment)):    
            asi = asi and interpolated[i]
        return asi

    def set_phi(self, phi):
        if not self.all_segments_interpolated():
            self.interpolate()

        self.current_phi = phi
        self.current_position = np.zeros(self.dim)
        self.current_velocity = np.zeros(self.dim)
        self.current_acceleration = np.zeros(self.dim)
        for j in range(self.dim):
            self.current_position[j]     = self.traj[j].position( t = phi )
            self.current_velocity[j]     = self.traj[j].velocity( t = phi )
            self.current_acceleration[j] = self.traj[j].acceleration( t = phi )

    def plot(self, axis = 0, n = 100, y_text = "", wtp = 'position'):
        if y_text == "":
            s = wtp
        else:
            s = wtp + " of: " + y_text

        x = np.arange(0.0, self.phi_end, self.phi_end/n)
        y = copy.copy(x)
        for i in range(len(x)):
            self.set_phi(x[i])
            if wtp == 'position':
                y[i] = self.current_position[axis]
                # print x[i],y[i]    
            elif wtp == 'velocity':
                y[i] = self.current_velocity[axis]
            elif wtp == 'acceleration':
                y[i] = self.current_acceleration[axis]
            else:
                print "Error from Trajectory.plot(): Given wtp is not valid"
        plt.plot(x, y) 
        plt.ylabel(s)
        plt.xlabel('phi')
        plt.show()

    def scatter_plot(self, wtp = 'position', axis_x = 0, axis_y = 1, n = 100, y_text = ""):

        t = np.arange(0.0, self.phi_end, self.phi_end/n)
        x = copy.copy(t)
        y = copy.copy(t)
        for i in range(len(x)):
            self.set_phi(t[i])
            if wtp == 'position':
                x[i] = self.current_position[axis_x]
                y[i] = self.current_position[axis_y]
            elif wtp == 'velocity':
                x[i] = self.current_velocity[axis_x]
                y[i] = self.current_velocity[axis_y]
            elif wtp == 'acceleration':
                x[i] = self.current_acceleration[axis_x]
                y[i] = self.current_acceleration[axis_y]
            else:
                print "Error from Trajectory.plot(): Given wtp is not valid"
        plt.plot(x, y) 
        plt.ylabel('Y')
        plt.xlabel('X')
        plt.show()

class Polynomial_Trajectory(Trajectory):
    def __init__(self, dimension = 3):
        super(Polynomial_Trajectory, self).__init__(dimension = dimension)            
        self.traj = [pl.Polynomial() for j in range(self.dim)] 

    def interpolate_segment(self, seg_number):
        
    def interpolate(self, phi = [0.0], positions = [np.zeros(3)], velocities = None, accelerations = None):
        '''
        specifies the coefficients of the spline passing through the key points of a segment
        At least one position and one phi is required.
        phi[0] must be zero.
        '''
        n = len(phi)
        assert n > 0
        assert n == len(positions)
        assert phi[0] == 0.0

        self.dim = len(positions[0]) # dimension of position vector
        nn  = np.array([None for j in range(self.dim)])
        for i in range(n):
            if positions[i] == None:
                positions[i] = copy.copy(nn)

        if velocities == None:
            velocities = [copy.copy(nn) for i in range(n)]
        else:
            assert n == len(velocities)
            for i in range(n):
                if velocities[i] == None:
                    velocities[i] = copy.copy(nn)

        if accelerations == None:
            accelerations = [copy.copy(nn) for i in range(n)]
        else:
            assert n == len(accelerations)
            for i in range(n):
                if accelerations[i] == None:
                    accelerations[i] = copy.copy(nn)

        pnt = [[] for j in range(self.dim)]

        for i in range(n):
            for j in range(self.dim):
                pnt[j].append(pl.Point(t = phi[i], x = positions[i][j], v = velocities[i][j], a = accelerations[i][j]))

        for j in range(self.dim):
            self.traj[j].interpolate_smart(pnt[j])

        self.phi_end = phi[n-1]

def line_3D(initial_pos, final_pos, initial_vel = np.zeros(3), final_vel = np.zeros(3)):
    tr = Polynomial_Trajectory()
    tr.interpolate([0.0, 1.0], positions = [initial_pos, final_pos], velocities = [initial_vel, final_vel])
    return tr


class Orientation_Trajectory(object):
    def __init__(self, initial_orientation = np.eye(3)):
        self.current_orientation = initial_orientation
        self.phi_end = 1.0

    def set_phi(self, phi):
        self.current_phi = phi 
