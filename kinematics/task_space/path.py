'''   Header
@file:          path.py
@brief:    	    This module provides a class containing a path in the taskspace.
                The path is generated by a number of trajectories
                
@author:        Nima Ramezani Taghiabadi
                PhD Researcher
                Faculty of Engineering and Information Technology
                University of Technology Sydney (UTS)
                Broadway, Ultimo, NSW 2007, Australia
                Room No.: CB10.03.512
                Phone:    02 9514 4621
                Mobile:   04 5027 4611
                Email(1): Nima.RamezaniTaghiabadi@student.uts.edu.au 
                Email(2): nima.ramezani@gmail.com
                Email(3): nima_ramezani@yahoo.com
                Email(4): ramezanitn@alum.sharif.edu
@version:	    1

Last Revision:  17 July 2014

'''

import matplotlib.pyplot as plt
import numpy as np
import trajectory as trajlib
import copy, math

from packages.nima.mathematics import polynomials as pl
from packages.nima.mathematics import general as gen


class Path(object):
    def __init__(self):
        self.trajectory = []
        self.trajectory_start = []
        self.phi_end = 0.0

    def connect_trajectories(self, new_trajectories):

        for tr in new_trajectories:
            self.trajectory.append(tr)
            self.trajectory_start.append(self.phi_end)
            self.phi_end = self.phi_end + tr.phi_end

    def connect_to_points(self, delta_times, new_points, velocity_consistent = True, acceleration_consistent = True):
        '''
        Adds a number of points to the path. makes a polynomial trajectory and appends it to the end of trajectory list
        new_points: new positions
        '''
        n = len(new_points)
        dim = len(new_points[0])
        n_trajectory = len(self.trajectory)
        if n_trajectory == 0:
            assert n == len(delta_times) + 1
            vel   = [None for i in range(n)] 
            acc   = [None for i in range(n)] 
            times = [0.0 for i in range(n)]
            for i in range(n-1):
                times[i+1] = times[i] + delta_times[i]
            if velocity_consistent:
                vel[0] = np.zeros(dim)
            if acceleration_consistent:
                acc[0] = np.zeros(dim)
            trj = trajlib.Polynomial_Trajectory(dimension = dim)
            trj.interpolate(phi = times, positions = new_points, velocities = vel, accelerations = acc)
            self.trajectory       = [trj]
            self.trajectory_start = [0.0]
        else:
            assert n == len(delta_times)
            vel   = [None for i in range(n+1)] 
            acc   = [None for i in range(n+1)] 
            times = [0.0 for i in range(n+1)]
            for i in range(n):
                times[i+1] = times[i] + delta_times[i]

            self.trajectory[n_trajectory - 1].set_phi(self.trajectory[n_trajectory - 1].phi_end)  # go to the end of trajectory
            pre_pos = self.trajectory[n_trajectory - 1].current_position
            if velocity_consistent:
                vel[0] = self.trajectory[n_trajectory - 1].current_velocity
            if acceleration_consistent:
                acc[0] = self.trajectory[n_trajectory - 1].current_acceleration
            
            trj = trajlib.Polynomial_Trajectory(dimension = dim)
            trj.interpolate(phi = times, positions = [pre_pos] + new_points, velocities = vel, accelerations = acc)
            self.trajectory_start.append(self.trajectory_start[n_trajectory-1] + self.trajectory[n_trajectory-1].phi_end)
            self.trajectory.append(trj)

    def set_phi(self, phi):
        if phi > self.phi_end:
            phi = self.phi_end
        self.current_phi = phi

        lpi     = len(self.trajectory)-1 # last trajectory index
        phi_max = self.trajectory_start[lpi] + self.trajectory[lpi].phi_end 

        phi = phi*phi_max/self.phi_end

        if phi > phi_max:
            phi = phi_max

        i = 0
        while (phi > self.trajectory_start[i] + self.trajectory[i].phi_end) and (i < len(self.trajectory)):
            i += 1
        
        self.trajectory[i].set_phi(phi - self.trajectory_start[i])
        self.current_position = self.trajectory[i].current_position
        self.current_velocity = self.trajectory[i].current_velocity
        self.current_acceleration = self.trajectory[i].current_acceleration
       
    def plot(self, wtp = 'position', axis = 0, n = 100, y_text = ""):
        if y_text == "":
            s = wtp
        else:
            s = wtp + " of: " + y_text

        x = np.arange(0.0, self.phi_end, self.phi_end/n)
        y = copy.copy(x)
        for i in range(len(x)):
            self.set_phi(x[i])
            if wtp == 'position':
                y[i] = self.current_position[axis]
            elif wtp == 'velocity':
                y[i] = self.current_velocity[axis]
            elif wtp == 'acceleration':
                y[i] = self.current_acceleration[axis]
            else:
                print "Error from Path.plot(): Given wtp is not valid"
        plt.plot(x, y) 
        plt.ylabel(s)
        plt.xlabel('phi')
        plt.show()

    '''
    def position(self, phi):
        phi0 = self.    
    '''
                
