'''   Header
@file:          trajectory.py
@brief:    	    This module provides a class containing a trajectory in the taskspace.
                The trajectory is generated by a number of key points containing poses, twists and corresponding phase phi
                
@author:        Nima Ramezani Taghiabadi
                PhD Researcher
                Faculty of Engineering and Information Technology
                University of Technology Sydney (UTS)
                Broadway, Ultimo, NSW 2007, Australia
                Room No.: CB10.03.512
                Phone:    02 9514 4621
                Mobile:   04 5027 4611
                Email(1): Nima.RamezaniTaghiabadi@student.uts.edu.au 
                Email(2): nima.ramezani@gmail.com
                Email(3): nima_ramezani@yahoo.com
                Email(4): ramezanitn@alum.sharif.edu
@version:	    2

Last Revision:  07 July 2014

Changes from version 1:
    1- In version 2, trajectories can have multiple paths, connection of trajectories means connecting the paths to each other.
    old class Trajectory(), is now a class Path() and a Trajectory is a set of paths.

    2- In version 1, positions are three dimensional, while in version 2, positions can be multi dimensional(more or less than 3)

    3- Orientations, angular velocities and ang. acc. have been removed. There will be another trajectory type for them in the future
        At the moment, orientations, angular velocities and angular accelerations are not supported.

'''

import matplotlib.pyplot as plt
import numpy as np
import copy, math

# from packages.nima.mathematics import vectors_and_matrices as vm
from packages.nima.mathematics import polynomials as pl
from packages.nima.mathematics import general as gen

class Path(object):
    
    def __init__(self):
        self.n = 1  # Number of keypoints. By default the trajectory is a constant pose (not changing)
        self.current_phi = 0
        self.dim = 3
        self.current_position = np.zeros(self.dim)
        self.current_velocity = np.zeros(self.dim)
        self.current_acceleration = np.zeros(self.dim)

    def interpolate(self, phi = [0.0], positions = [np.zeros(3)], velocities = None, accelerations = None):
        '''
        specifies the coefficients of the trajectory which passes through a number of poses
        At least one position and one phi is required.
        phi[0] must be zero.
        '''
        n = len(phi)
        assert n > 0
        assert n == len(positions)
        assert phi[0] == 0.0

        self.dim = len(positions[0]) # dimension of position vector
        nn  = np.array([None for j in range(self.dim)])
        for i in range(n):
            if positions[i] == None:
                positions[i] = copy.copy(nn)

        if velocities == None:
            velocities = [copy.copy(nn) for i in range(n)]
        else:
            assert n == len(velocities)
            for i in range(n):
                if velocities[i] == None:
                    velocities[i] = copy.copy(nn)

        if accelerations == None:
            accelerations = [copy.copy(nn) for i in range(n)]
        else:
            assert n == len(accelerations)
            for i in range(n):
                if accelerations[i] == None:
                    accelerations[i] = copy.copy(nn)

        pnt = [[] for j in range(self.dim)]

        for i in range(n):
            for j in range(self.dim):
                pnt[j].append(pl.Point(t = phi[i], x = positions[i][j], v = velocities[i][j], a = accelerations[i][j]))

        self.traj = [pl.Polynomial() for j in range(self.dim)] 

        for j in range(self.dim):
            self.traj[j].interpolate_smart(pnt[j])

        self.phi_end = phi[n-1]

    def set_phi(self, phi):
        self.current_phi = phi
        self.current_position = np.zeros(self.dim)
        self.current_velocity = np.zeros(self.dim)
        self.current_acceleration = np.zeros(self.dim)
        for j in range(self.dim):
            self.current_position[j]     = self.traj[j].position( t = phi )
            self.current_velocity[j]     = self.traj[j].velocity( t = phi )
            self.current_acceleration[j] = self.traj[j].acceleration( t = phi )

# Special Trajectories
    
class Colin_Graf_Trajectory(object):
    '''
    A one dimensional trajectory based on paper written by Colin Graf et.al. 2009
    "A Robust Closed-Loop Gait for the Standard Platform League Humanoid" 
    Proceedings of the 4th Workshop on Humanoid Soccer Robots
    '''
    def __init__(self, xl = 0.22, yl=0.55, xm=0.22, ym=0.55, h=30.0, dx=0.0, dy=120.0, Ol=np.array([-55,25,-385]), Or=np.array([55,25,-385]), Cs=np.zeros(3), Ss=np.array([20.0,0.0,0.0])):
        self.xl  = xl
        self.yl  = yl
        self.xm  = xm
        self.ym  = ym
        self.h   = h
        self.dx  = dx
        self.dy  = dy
        self.Ol  = Ol
        self.Or  = Or
        self.Cs  = Cs
        self.Ss  = Ss
        
    def tl_lift(self, phi):
        if (2*phi > self.xl) and (2*phi < self.xl + self.yl):
            return 0.5*(1.0- math.cos(2*math.pi*(2*phi-self.xl)/self.yl))
        else:
            return 0.0

    def tr_lift(self, phi):
        return self.tl_lift(phi-0.5)

    def tl_move(self, phi):
        if (2*phi > self.xm) and (2*phi < self.xm + self.ym):
            return 0.5*(1.0- math.cos(math.pi*(2*phi-self.xm)/self.ym))
        elif (2*phi >= self.xm + self.ym) and (2*phi <= 1.0):
            return 1.0
        else:
            return 0.0

    def tr_move(self, phi):
        return self.tl_move(phi-0.5)
            
    def tl(self, phi):
        if phi < 0.5:
            return 0.5*(1.0 - math.cos(2.0*math.pi*phi))
        else:
            return 0.0

    def tr(self, phi):
        if phi >= 0.5:
            return 0.5*(1.0 - math.cos(2.0*math.pi*(phi-0.5)))
        else:
            return 0.0

    def t_com(self, phi):    
        def ss(t):
            return math.sin(2*math.pi*t)
        def rr(t):
            s = ss(t)
            return math.sqrt(abs(s))*gen.sign(s)
        def ll(t):
            if (t < 0.25):
                return 4*t
            elif (t >= 0.25) and (t < 0.75):
                return 2 - 4*t
            else:
                return 4*(t - 1)
        xc = 20.0
        yc = 50.0
        zc = 2.0
        return (xc*ss(phi) + yc*rr(phi) + zc*ll(phi))/(xc + yc + zc)

    def t_lin(self, phi):
        if (phi < 0.5):
            return 2*phi
        else:
            return 2*phi - 1.0

    def pl_rel(self, phi):
        sl_lift = np.array([0.0, 0.0, self.h])
        sl      = np.array([self.dx, self.dy, 0.0])
        sr      = sl
        if (phi < 0.5):
            return self.Ol + sl_lift*self.tl_lift(phi) + sl*self.tl_move(phi) + sr*(1.0 - self.tl_move(phi))*self.tl(phi)
        else:
            return self.Ol + sl_lift*self.tl_lift(phi) + sl*(1.0 - self.tr(phi))
             
    def pr_rel(self, phi):
        sr_lift = np.array([0.0, 0.0, self.h])
        sl      = np.array([self.dx, self.dy, 0.0])
        sr      = sl 
        if (phi >= 0.5):
            return self.Or + sr_lift*self.tr_lift(phi) + sr*self.tr_move(phi) + sl*(1.0 - self.tr_move(phi))*self.tr(phi)
        else:
            return self.Or + sr_lift*self.tr_lift(phi) + sr*(1.0 - self.tl(phi))

    def pl_com(self, phi):
        sl      = np.array([self.dx, self.dy, 0.0])
        sr      = sl
        if (phi < 0.5):
            return - self.Cs + self.Ss*self.t_com(phi) + self.Ol - 0.5*(sl*self.t_lin(phi) - sr*(1.0 - self.t_lin(phi)))
        else:
            return self.pr_com(phi) - self.pr_rel(phi) + self.pl_rel(phi)

    def pr_com(self, phi):
        sl      = np.array([self.dx, self.dy, 0.0])
        sr      = sl
        if (phi >= 0.5):
            return - self.Cs + self.Ss*self.t_com(phi) + self.Or - 0.5*(sr*self.t_lin(phi) - sl*(1.0 - self.t_lin(phi)))
        else:
            return self.pl_com(phi) - self.pl_rel(phi) + self.pr_rel(phi)
    
    def plot(self, wtp = 'pl_com_x', n = 100):
        '''
        wtp (what to plot) is a string indicating which trajectory to be plotted
        n specifies how many points need to be created in the trajectory function domain
        '''
        x = np.arange(0.0, 1.0, 1.0/n)
        y = copy.copy(x)
        for i in range(n):
            if wtp == 'pl_com_x':
                y[i] = self.pl_com(x[i])[0]
            elif wtp == 'pl_com_y':
                y[i] = self.pl_com(x[i])[1]
            elif wtp == 'pl_com_z':
                y[i] = self.pl_com(x[i])[2]
            elif wtp == 'pr_com_x':
                y[i] = self.pr_com(x[i])[0]
            elif wtp == 'pr_com_y':
                y[i] = self.pr_com(x[i])[1]
            elif wtp == 'pr_com_z':
                y[i] = self.pr_com(x[i])[2]
            elif wtp == 'pl_rel_x':
                y[i] = self.pl_rel(x[i])[0]
            elif wtp == 'pl_rel_y':
                y[i] = self.pl_rel(x[i])[1]
            elif wtp == 'pl_rel_z':
                y[i] = self.pl_rel(x[i])[2]
            elif wtp == 'pr_rel_x':
                y[i] = self.pr_rel(x[i])[0]
            elif wtp == 'pr_rel_y':
                y[i] = self.pr_rel(x[i])[1]
            elif wtp == 'pr_rel_z':
                y[i] = self.pr_rel(x[i])[2]
            elif wtp == 'tl_lift':
                y[i] = self.tl_lift(x[i])
            elif wtp == 'tr_lift':
                y[i] = self.tr_lift(x[i])
            elif wtp == 't_com':
                y[i] = self.t_com(x[i])
            elif wtp == 'tl_move':
                y[i] = self.tl_move(x[i])
            elif wtp == 'tr_move':
                y[i] = self.tr_move(x[i])
            elif wtp == 'tr':
                y[i] = self.tr(x[i])
            elif wtp == 'tl':
                y[i] = self.tl(x[i])

        plt.plot(x, y) 
        plt.ylabel(wtp)
        plt.xlabel('phi')
        plt.show()

class Trajectory(object):
    def __init__(self):
        self.path = []

    def connect(self, delta_times, new_points, velocity_consistent = True, acceleration_consistent = True):
        n = len(new_points)
        dim = len(new_points[0])
        n_path = len(self.path)
        if n_path == 0:
            assert n == len(delta_times) + 1
            vel   = [None for i in range(n)] 
            acc   = [None for i in range(n)] 
            times = [0.0 for i in range(n)]
            for i in range(n-1):
                times[i+1] = times[i] + delta_times[i]
            if velocity_consistent:
                vel[0] = np.zeros(dim)
            if acceleration_consistent:
                acc[0] = np.zeros(dim)
            pth = Path()
            pth.interpolate(phi = times, positions = new_points, velocities = vel, accelerations = acc)
            self.path       = [pth]
            self.path_start = [0.0]
        else:
            assert n == len(delta_times)
            vel   = [None for i in range(n+1)] 
            acc   = [None for i in range(n+1)] 
            times = [0.0 for i in range(n+1)]
            for i in range(n):
                times[i+1] = times[i] + delta_times[i]

            self.path[n_path - 1].set_phi(self.path[n_path - 1].phi_end)  # go to the end of path
            pre_pos = self.path[n_path - 1].current_position
            if velocity_consistent:
                vel[0] = self.path[n_path - 1].current_velocity
            if acceleration_consistent:
                acc[0] = self.path[n_path - 1].current_acceleration
            
            pth = Path()
            pth.interpolate(phi = times, positions = [pre_pos] + new_points, velocities = vel, accelerations = acc)
            self.path_start.append(self.path_start[n_path-1] + self.path[n_path-1].phi_end)
            self.path.append(pth)

    def set_phi(self, phi):
        '''
        lpi  = len(self.path)-1 # last path index
        phi2 = self.path_start[lpi] + self.path[lpi].phi_end 
        if phi > phi2:
            phi = phi2
        '''
        self.current_phi = phi
        i = 0
        while (phi > self.path_start[i] + self.path[i].phi_end) and (i < len(self.path)):
            i += 1
        
        self.path[i].set_phi(phi - self.path_start[i])
        self.current_position = self.path[i].current_position
        self.current_velocity = self.path[i].current_velocity
        self.current_acceleration = self.path[i].current_acceleration
       
    def plot(self, wtp = 'position', axis = 0, n = 100):
        lpi  = len(self.path)-1 # last path index
        phi2 = self.path_start[lpi] + self.path[lpi].phi_end 
        x = np.arange(0.0, phi2, phi2/n)
        y = copy.copy(x)
        for i in range(len(x)):
            self.set_phi(x[i])
            if wtp == 'position':
                y[i] = self.current_position[axis]
            elif wtp == 'velocity':
                y[i] = self.current_velocity[axis]
            elif wtp == 'acceleration':
                y[i] = self.current_acceleration[axis]
            else:
                print "Error from Trajectory.set_phi(): Given wtp is not valid"
        plt.plot(x, y) 
        plt.ylabel(wtp)
        plt.xlabel('phi')
        plt.show()

    '''
    def position(self, phi):
        phi0 = self.    
    '''
class Orientation_Trajectory(object):
    def __init__(self):
        self.current_orientation = np.eye(3)        
                
