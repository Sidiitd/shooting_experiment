'''   Header
@file:          trajectory.py
@brief:    	    This module provides a class containing a trajectory in the taskspace.
                The path is generated by a number of key points containing poses, twists and corresponding phase phi
                
@author:        Nima Ramezani Taghiabadi
                PhD Researcher
                Faculty of Engineering and Information Technology
                University of Technology Sydney (UTS)
                Broadway, Ultimo, NSW 2007, Australia
                Room No.: CB10.03.512
                Phone:    02 9514 4621
                Mobile:   04 5027 4611
                Email(1): Nima.RamezaniTaghiabadi@student.uts.edu.au 
                Email(2): nima.ramezani@gmail.com
                Email(3): nima_ramezani@yahoo.com
                Email(4): ramezanitn@alum.sharif.edu
@version:	    3

Last Revision:  17 July 2014

Major changes from version 2:
    1- Names of "Path" and "Trajectory" have been swapped. In fact, in the new version, a "path" contains multiple "trajectories" connected to each other
    2- In the new version , class Polynomial_Trajectory() has been separated as a child of parent class Trajectory()
        different childs like Fourier_Trajectory or ... any special trajectories can be considered

'''

import matplotlib.pyplot as plt
import numpy as np
import copy, math

from packages.nima.mathematics import polynomials as pl
from packages.nima.mathematics import general as gen


class Trajectory(object):
    
    def __init__(self, dimension = 3):
        self.n = 1  # Number of keypoints. By default the trajectory is a constant pose (not changing)
        self.current_phi = 0.0
        self.phi_end = 1.0

        self.dim = dimension
        self.current_position = np.zeros(self.dim)
        self.current_velocity = np.zeros(self.dim)
        self.current_acceleration = np.zeros(self.dim)

    def set_phi(self, phi):
        self.current_phi = phi
        self.current_position = np.zeros(self.dim)
        self.current_velocity = np.zeros(self.dim)
        self.current_acceleration = np.zeros(self.dim)
        for j in range(self.dim):
            self.current_position[j]     = self.traj[j].position( t = phi )
            self.current_velocity[j]     = self.traj[j].velocity( t = phi )
            self.current_acceleration[j] = self.traj[j].acceleration( t = phi )

    def plot(self, axis = 0, n = 100, y_text = "", wtp = 'position'):
        if y_text == "":
            s = wtp
        else:
            s = wtp + " of: " + y_text

        x = np.arange(0.0, self.phi_end, self.phi_end/n)
        y = copy.copy(x)
        for i in range(len(x)):
            self.set_phi(x[i])
            if wtp == 'position':
                y[i] = self.current_position[axis]
                # print x[i],y[i]    
            elif wtp == 'velocity':
                y[i] = self.current_velocity[axis]
            elif wtp == 'acceleration':
                y[i] = self.current_acceleration[axis]
            else:
                print "Error from Trajectory.plot(): Given wtp is not valid"
        plt.plot(x, y) 
        plt.ylabel(s)
        plt.xlabel('phi')
        plt.show()

    def scatter_plot(self, wtp = 'position', axis_x = 0, axis_y = 1, n = 100, y_text = ""):

        t = np.arange(0.0, self.phi_end, self.phi_end/n)
        x = copy.copy(t)
        y = copy.copy(t)
        for i in range(len(x)):
            self.set_phi(t[i])
            if wtp == 'position':
                x[i] = self.current_position[axis_x]
                y[i] = self.current_position[axis_y]
            elif wtp == 'velocity':
                x[i] = self.current_velocity[axis_x]
                y[i] = self.current_velocity[axis_y]
            elif wtp == 'acceleration':
                x[i] = self.current_acceleration[axis_x]
                y[i] = self.current_acceleration[axis_y]
            else:
                print "Error from Trajectory.plot(): Given wtp is not valid"
        plt.plot(x, y) 
        plt.ylabel('Y')
        plt.xlabel('X')
        plt.show()

class Polynomial_Trajectory(Trajectory):
    def __init__(self, dimension = 3):
        super(Polynomial_Trajectory, self).__init__(dimension = dimension)            
        self.traj = [pl.Polynomial() for j in range(self.dim)] 

    def interpolate(self, phi = [0.0], positions = [np.zeros(3)], velocities = None, accelerations = None):
        '''
        specifies the coefficients of the trajectory_tbc_path which passes through a number of poses
        At least one position and one phi is required.
        phi[0] must be zero.
        '''
        n = len(phi)
        assert n > 0
        assert n == len(positions)
        assert phi[0] == 0.0

        self.dim = len(positions[0]) # dimension of position vector
        nn  = np.array([None for j in range(self.dim)])
        for i in range(n):
            if positions[i] == None:
                positions[i] = copy.copy(nn)

        if velocities == None:
            velocities = [copy.copy(nn) for i in range(n)]
        else:
            assert n == len(velocities)
            for i in range(n):
                if velocities[i] == None:
                    velocities[i] = copy.copy(nn)

        if accelerations == None:
            accelerations = [copy.copy(nn) for i in range(n)]
        else:
            assert n == len(accelerations)
            for i in range(n):
                if accelerations[i] == None:
                    accelerations[i] = copy.copy(nn)

        pnt = [[] for j in range(self.dim)]

        for i in range(n):
            for j in range(self.dim):
                pnt[j].append(pl.Point(t = phi[i], x = positions[i][j], v = velocities[i][j], a = accelerations[i][j]))

        for j in range(self.dim):
            self.traj[j].interpolate_smart(pnt[j])

        self.phi_end = phi[n-1]

def line_3D(initial_pos, final_pos, initial_vel = np.zeros(3), final_vel = np.zeros(3)):
    tr = Polynomial_Trajectory()
    tr.interpolate([0.0, 1.0], positions = [initial_pos, final_pos], velocities = [initial_vel, final_vel])
    return tr


class Orientation_Trajectory(object):
    def __init__(self, initial_orientation = np.eye(3)):
        self.current_orientation = initial_orientation
        self.phi_end = 1.0

    def set_phi(self, phi):
        self.current_phi = phi 
